---
layout: post
title: 约瑟夫（joseph）问题
date: '2013-05-13 00:00:00'
categories:
  - 姿势
tags:
  - 数学
  - 递推
description: 约瑟夫是一个经典的问题，提供了一种简单的递推思路。
reference:
  - title: 约瑟夫环学习小记 - whyorwhnt的专栏
    url: 'http://blog.csdn.net/whyorwhnt/article/details/8483350'
  - title: 约瑟夫环问题的公式推导 | 江山如画
    url: 'http://www.bitsucker.com/archives/7'
  - title: 扩展约瑟夫问题的解法_哀·时光机
    url: 'http://hi.baidu.com/starwing/item/1bbfadda2bc3034cfa57682d'
  - title: 约瑟夫问题_百度百科
    url: 'http://baike.baidu.com.cn/view/213217.htm'
---

# 基础知识

约瑟夫问题，又被叫做“约瑟夫斯变换”，是一个很经典的动态规划方面的问题。问题的描述是这样的。有n个人，从1开始编号至n，这n个人排成一个圆圈，从第一个人开始报数，报到m的人出列，剩下的人重新围成圆圈，从出列的那个人的下一个人开始又从1开始报数，以此类推。直到圆圈里最后剩下一个人为止，现在求这个人的编号。  

# 问题解法

关于约瑟夫问题，主要有以下几种形式：  

## 朴素解法（模拟）

根据问题描述，模拟出圈动作的进行。建议写成循环链表的形式。  

这种方法可以解出每次出圈的人在 **整个圈** 的编号，时间复杂度有点高。  

代码示例（数组模拟）：  

```cpp
#include<iostream>
using namespace std;
int main()
{
    int n,m,a[101],k,i,j,num; //计数器是从1开始的，所以100个人用101
    cout<<"请输入参加游戏的玩家人数(不超过100人):";
    cin>>n;
    cout<<"----------------------------------------"<<endl;
    if(n>100）
    {
        cout<<"玩家太多，请重新登陆此程序！"<<endl;
        return 0;
    }
    cout<<"输入游戏中要玩的数字：";
    cin>>m;
    cout<<"----------------------------------------"<<endl;
    for(i=1;i<=n;i++)
    {
        a[i]=1;
    }
    j=0;
    k=0;
    for(i=1;i<=n;i++){
        if(a[i]==1）{
            j=j+a[i];
            if(j==m)
            {
            j=0;
            a[i]=0;
            k++;
            }
            if(k==n){
                num=i;
                break;
            }
        }
        if(i==n)
        i=0;
    }
    cout<<"最后获胜的玩家是第 "<<num<<" 号玩家！"<<endl;
    cout<<"----------------------------------------"<<endl;
    return 0;
}
```

## 求解最后出圈的人

为了讨论方便，先把问题稍微改变一下，并不影响原意：  

`问题描述：n个人（编号0~(n-1）），从0开始报数，报到（m-1）的退出，剩下的人继续从0开始报数。求胜利者的编号。`  

我们知道第一个人（编号一定是（m-1） mod n) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m mod n的人开始）：  
k k+1 k+2 ... n-2,n-1,0,1,2,... k-2  
并且从k开始报0。  

现在我们把他们的编号做一下转换：  

```
    旧的圆圈 | 新的圆圈
    ---------+---------
    ...      |   ...
    k - 2    |  n - 2
    k - 1    |  n - 1
    k        |   ??? <- 此人已出列
    k + 1    |    1
    k + 2    |    2
    ...      |   ...
```

变换后就完完全全成为了（n-1）个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k) mod n  

如何知道（n-1）个人报数的问题的解？对，只要知道（n-2）个人的解就行了。（n-2）个人的解呢？当然是先求（n-3）的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：  

令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]  

递推公式  

> f[1]=0;  
> f=(f+m) mod i; (i>1)

有了这个公式，我们要做的就是从1-n顺序算出f的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1。  

```cpp
    #include <stdio.h>
    int main()
    {
        int n,m,i,s=0;
        printf ("N M = ");
        scanf("%d%d",&n,&m);
        for (i=2; i<=n; i++) s=(s+m)%i;
        printf ("The winner is %d\n",s+1）;
    }
```

## 求解每次出圈的人

求解每次出圈的人，当然这不是严格意义上的每次出圈的人，而是出圈的人在**当前圈**的编号。  

则第i轮出局的人为f(i)=(f(i-1)+m-1)%(n-i+1),f(0)=0; f(i) 表示当前子序列中要退出的那个人（当前序列编号为0~(n-i));  

代码示例：  

```cpp
    #include <iostream>
    using namespace std;

    int ans[100];
    int test(int n,int m)
    {
        int i,j=0;
        for(i=0;i<n;i++)
        {
            j=(j+m-1)%(n-i);
            ans[i]=j;
        }
        return 1;
    }
    int main()
    {
        test(6,5);
        for(int i=0;i<6;i++)
            cout<<ans[i]<<endl;
        return 0;
    }
```

## 其它

还有其它一些变形，比如**每隔一人退出的特殊情况**，这个可以进一步优化，太菜了，看不懂。（参考《具体数学》7-14页）  
