---
title: 【手撕源码系列】防抖、节流、柯里化
date: 2021-11-03 11:01:18
tags:
    - JavaScript
categories:
    - 手撕源码
keywords: "面试,js基础"
description: 
cover: https://img.cdn.sugarat.top/mdImg/MTY0NjcwNDYzODcwMA==646704638700

---

# 防抖、节流、柯里化

这三个知识点主要的原理是闭包，还不了解闭包的同学看这里[什么是闭包]()

## 一、防抖和节流

什么是防抖？什么是节流？

**防抖**：事件被触发后延迟n秒再执行回调，如果在这n秒内又被触发，则重新计时。

>举例：当电脑设置自动锁屏的时间为10min，那我锁屏触发的条件就是我10分钟内没有任何动作才锁屏

### 防抖实现

实现步骤

- 设置定时器

- 防抖时间内调用清除定时器，开启新的计时器

- 改变this的指向

```js
function debounce(fn,delay){
    let timer = null
    
    // 返回一个闭包函数 用闭包保存timer，不会被销毁
    return function(){
        let args = arguments
     
        // let context = this
        // setTimeout中的this指向，如果是function函数，那么回调函数中this指向的是window对
        // 象，如果是箭头函数，那么指向的就是当前调用环境
        clearTimeout(timer)
        timer = setTimeout(()=>{
        
            // 这里注意this指向的问题
            fn.apply(this,args)
        })
    }
}
```

  **节流**：每过n秒仅执行一次回调函数。如单位时间内多次触发函数，也只有一次生效
>表单验证、提交等，只在一定时间只提交一次

### 节流实现

#### 时间戳版本(首节流)

```js
function throttle(fn,delay){
    
    // 记录第一次调用的时间
    let prev = null
    
    // 返回闭包函数
    return function(){
        
        // 保存事件参数
        let args = arguments
        
        // 记录现在的时间
        let now = Date.now()
        if(now - prev >= delay){
            
            // 执行函数
            fn.apply(this,args)
            
            // 改变时间
            prev = now
        }
    }
}
```

> 之所以叫首节流，是因为一开始触发事件就会执行，以后每过delay执行一次，有的人会说是首个prev设置的有问题，如果首个prev也能实时获取时间戳，但是只限于第一次是三秒后触发，只要停下来，再次触发也是立即执行

#### 定时器版本(尾节流)

```js
function throttle(fn,delay){
    
    // 重置定时器
    let timer = null
    
    // 返回闭包函数
    return function(){
        
        // 记录时间参数
        let args = arguments
        
        // 如果定时器为空
        if(!timer){
            timer = setTimeout(()=>{
                
                // 执行函数
                fn.apply(this,args)
                
                // 执行完后重置定时器
                timer = null
            },delay)
        }
    }
}
```

>第一次触发时不会执行，而是在`delay`秒之后才执行，当最后一次停止触发后，还会再执行一次函数。

#### 时间戳&定时器(首次执行、最后一次也执行)

```js
function throttle(fn,delay){
    
    // 初始化定时器
    let timer = null
    
    // 上一次调用时间
    let prev = null
    
    // 返回闭包函数
    return function(){
        
        // 现在触发事件时间
        let now = Date.now()
        
        // 触发时间间隔是否大于delay
        let remaing = delay - (now - prev)
        
        // 保存事件参数
        const args = arguments
        
        // 清除定时器
        clearTimeout(timer)
        
        // 如果时间间隔满足delay
        if(remaining <= 0){
            
            // 调用fn 并将现在的时间设置为上一次的执行时间
            fn.apply(this,args)
            prev = Date.now()
        } else {
            
            // 否则 过了剩余时间执行最后一次fn
            timer = setTimeout(()>{
                fn.apply(this,args)
            },delay)
        }
    }
}
```

## 二、柯里化

什么是函数柯里化呢？所谓”柯里化”，简单来说就是把一个多参数的函数，转化为单参数函数

```js
// 柯里化之前
function add(a, b, c) {
    return a + b + c
}
add(1, 2, 3) // 6

// 柯里化之后
let addCurry = curry(add)
addCurry(1)(2)(3) // 6
```

### 实现curry函数

- 调用curry函数，获取函数fn的参数。
- 定义一个新的函数judge，接收参数为`...args。`
- 判断新函数接受的参数长度是否大于等于fn剩余参数需要接收的长度
- 满足要求，则执行fn函数，并传入新函数的参数
- 否则，返回一个新的匿名函数，这个函数把所有传入参数`...args`保存在`arg`数组中，而这个匿名函数被执行后，就把以前收到的参数数组和当前的参数数组合并后，放到前面说的逻辑中，在judge函数里判断，重复第3步。

```js
function myCurry(fn) {
    let args1 = [].slice.call(arguments,1)
    let judge = (...args) => {
        let args2 = args1.concat(...args)
        if (args2.length >= fn.length) return fn(...args2)
        return (...arg) => judge(...args, ...arg)
    }
    return judge
}

function sum(a,b,c){
    console.log(a+b+c)
}

let add = myCurry(sum)

add(1, 2, 3) // 6
add(1, 2)(3) // 6
add(1)(2)(3) // 6
add(1)(2, 3) // 6

```

