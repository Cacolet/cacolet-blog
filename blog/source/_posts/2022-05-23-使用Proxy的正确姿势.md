---
layout: post
title: 在场景中使用Proxy的正确姿势
date: 2022-5-23 12:58:18
tags: [业务]
categories: [工作小结]
keywords: "Proxy,代理"
description: 在实习工作中的场景引申的对于Proxy的使用
cover: https://img.cdn.sugarat.top/mdImg/MTY2MDU0OTk0MTczOQ==660549941739
---

## 问题出现场景

今天在写代码的需求过程中碰到一个问题，就是后端给返回的一个逻辑字符串需要对应的对象将字符串的最终的值解析出来，用于当前对象中的商家是否满足可选的条件，简单还原下业务需求

需要对逻辑字符串的处理

```javascript
/*
 * 一级 | 代表 ||
 * 二级 ，代表 &&
 * 三级 . 代表 ||
 * */
let str = "store_name.store_name,ware_code.ware_name|store_name.store_code,ware_code.ware_name"
// 所以最终的字符串就是( (store_name || store_code) && (ware_code || ware_name) ) || ( (store_name || store_code) && (ware_code || ware_name) && category )
```

需要将下面的对象带入到逻辑字符串中

```js
// 将处理规则的字符串传进去
let f = Chu(str)

// 将对应的对象传进去处理返回布尔值
const store = {
    store_name: 'xxx',
    store_code: 'yyy'
}
// 没有的属性为 false
console.log(f(store))
```

## 我的思考

我想的是将一级、二级、三级拆出来，放到一个三维数组中，三级的布尔值通过对象是否有这个属性来获得，二级的布尔值通过三级的`或`操作获得，一级的通过二级的`与`操作获得，一级通过二级的`或`操作获得，也就是我们最终的值。

代码实现：

```js
function Chu(str) {
    let first_str = str.split("|")
    let second_str = first_str.map(item => {
        return item.split(",")
    })
    let third_str = second_str.map(item => {
        return item.map(item => {
            return item.split(".")
        })
    })
    return function (obj) {
        third_str[0][0] = (obj[third_str[0][0][0]] ? true : false) || (obj[third_str[0][0][1]] ? true : false)
        third_str[0][1] = (obj[third_str[0][1][0]] ? true : false) || (obj[third_str[0][1][1]] ? true : false)
        third_str[1][0] = (obj[third_str[1][0][0]] ? true : false) || (obj[third_str[1][0][1]] ? true : false)
        third_str[1][1] = (obj[third_str[1][1][0]] ? true : false) || (obj[third_str[1][1][1]] ? true : false)
        third_str[0] = third_str[0][0] || third_str[0][1]
        third_str[1] = third_str[1][0] || third_str[1][1]
        third_str = third_str[0] || third_str[1]
        return third_str
    }
}

```

这里其实应该可以递归去处理的，但是具体的场景还会存在不规则的字符串，在二级的时候多一个属性，像`store_name.store_name,ware_code.ware_name|store_name.store_code,ware_code.ware_name,cagetory`这个字符串就不规则。

## 与导师一起review代码后

针对上面的不规则情况，还是决定用表达式的形式来处理，将字符串处理为一个正确的逻辑表达式，但是是一个字符串，我们可以用`eval`来执行，但是会存在对象中没有属性的报错以及作用域的问题，最终的方案就是使用new Function + with + Proxy 的方式，通过提供作用域的方式，判断是否可选

```js

function chu(str) {
    // 将classifyCodes翻译成完整的与或关系字符串
    const logicStr = classifyCodes.split('|').map(combine => {
        return '(' + combine.split(',').map(condition => {
            const hasDot = condition.indexOf('.') > -1
            return '(' + condition.split('.').slice(hasDot ? 1 : 0).join(' || ') + ')'
        }).join(' && ') + ')'
    }).join(' || ')

    return ctx => {
        // ctx对象作为第一层作用域，需要经过proxy代理处理后使用，避免报错
        const proxyCtx = new Proxy(ctx, {
            has() {
                return true
            },
            get(target, p, receiver) {
                if (p in target) {
                    return Reflect.get(target, p, receiver)
                }
                return false
            }
        })

        return new Function('obj', `with (obj) { return ${logicStr} }`)(proxyCtx)
    }
}
```

这里有[Proxy的用法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)