---
title: 【每日算法】经典排序算法
date: 2021-11-07 16:58:18
tags:
    - JavaScript
    - 算法
categories:
    - 前端算法
keywords: "面试,js算法"
description: 与前端相关的算法
cover: https://img.cdn.sugarat.top/mdImg/MTY0NzY3OTY4OTgzMA==647679689830


---

## 冒泡排序

### 描述

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

### 代码

```js
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

## 选择排序

### 描述

n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### 代码实现

```js
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
```

## 插入排序

### 描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

- 从第一个元素开始，该元素可以认为已经被排序；

- 取出下一个元素，在已经排序的元素序列中从后向前扫描；

- 如果该元素（已排序）大于新元素，将该元素移到下一位置；

- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；

- 将新元素插入到该位置后；

- 重复步骤2~5。

### 代码实现

```js
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
```

## 归并排序

### 描述

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

### 代码实现

```js
function mergeSort(arr) {
    var len = arr.length;
    if (len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length>0 && right.length>0) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
```

## 快速排序

### 描述

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

### 代码实现

```js
function quickSort(arr) {
    if(arr.length <= 1){
        return arr
    }
    // 取基准点
    const midIndex = arr.length >> 1
    const valArr = arr.splice(midIndex,1)
    const midIndexval = valArr[0]
    const left = []
    const right = []

    for(let i = 0;i < arr.length;i++){
        if(arr[i] > midIndexval){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return quickSort1(left).concat(midIndexval,quickSort1(right))
}
```

这个版本需要开多于的空间内存，我们再写个只需要自身的数组便可以完成的快排

```js
function quickSort(arr){
    let x = arr[0];
    let length = arr.length;
    let i = 0;
    let j = length - 1;

    while(i < j) {
        // 先从后往前找小的, 没找到继续找
        while(i < j && arr[j] > x) {
            j--;
        }
        // 找到了，将值填入坑里, a[j]又变成了坑
        if(i < j) {
            a[i] = a[j];
        }

        // 然后从前往后找大的，没找到继续找
        while(i < j && arr[i] < x) {
            i++;
        }
        // 找到了，将值填入之前的坑里
        if(i < j) {
            a[j] = a[i];
        }
    }

    // 将基准值填入坑
    a[i] = x;
    return arr;
}
```

