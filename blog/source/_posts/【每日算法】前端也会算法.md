---
title: 【每日算法】前端也会算法
date: 2021-11-01 16:58:18
tags:
    - JavaScript
    - 算法
categories:
    - 前端算法
keywords: "面试,js算法"
description: 与前端相关的算法
cover: https://img.cdn.sugarat.top/mdImg/MTY0NzY3OTY4OTgzMA==647679689830

---

## 数组去重

之所以写这个在大众看来比较简单的问题，但是写的目的不在于解决这个问题，而是在于解决这个问题有多少中方法，每种方法的原理和实现思路这次我们该学习的

### 双层循环

这种方法常被人嗤之以鼻，但是我觉得，既然能解决问题，什么方法不是方法？再说了，你用高级语法就一定能适用所有的场景吗？有的浏览器这时候肯定会出来捅你一刀的

```js
let arr = [1, 2, 2, 3, 5, 5, 0]

function uniqune(arr) {
    let res = []
    for (let i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr.length; j++) {
            if (arr[i] === res[j]) {
                break
            }
        }
        if (j === arr.length) {
            res.push(arr[i])
        }
    }
    return res
}

console.log(uniqune(arr)) // [1,2,3,5,0]
```

### indexOf

我们可以用indexOf进行简化

```js
function uniqune(arr) {
    let res = []
    for (let i = 0; i < arr.length; i++) {
        if(arr.indexOf(arr[i]) === i){
            res.push(arr[i])
        }
    }
    return res
}
```

当然这里的循环方法很多，像什么map，forEach，filter，reduce等，能返回数组的就是直接返回，不能返回数组的定义一个数组去接受。

这里用`filter`这个API实现

```js
var array = [1, 2, 1, 1, '1'];

function unique(array) {
    var res = array.filter(function(item, index, array){
        return array.indexOf(item) === index;
    })
    return res;
}

console.log(unique(array));
```

再用`reduce`实现一下

```js
function unique(arr) {
        // reduce : 第一个是函数，第二个参数会传给第一次回调的prev;
        return arr.reduce((prev,next)=>{
            // 该函数返回值是下一次执行的prev;
            return prev.includes(next)?prev:[...prev,next];
        },[])
    }
    console.log(unique(arr));
```



### Object键值对

把数组的值存成Object的key值，比如Object[value] = true

```js
let arr = [1, 2, 2, 3, 5, 5, 0]

function uniqune(arr) {
    let obj = {}
    return arr.filter((item) =>{
        return obj.hasOwnProperty(item) ? false : obj[item] = true
    })

}

console.log(uniqune(arr)) // [1,2,3,5,0]
```

这样基本上已经完成去重的任务了，但是我们会想到是所有的类型都会去重吗？看一下下面这个

```js
let arr = [1, '1',2, 2, 3, 5, 5, 0]

function uniqune(arr) {
    let obj = {}
    return arr.filter((item) =>{
        return obj.hasOwnProperty(item) ? false : obj[item] = true
    })

}

console.log(uniqune(arr)) // [1,2,3,5,0]
```

结果还是这个，不应该是`[1,'1',2,3,5,0]`这是为什么呢？我们会发现普通对象的键值只能是String和symbol，所以当为key为number时，所以1变为了'1',接下来我们只要区分出对应的类型就行了，所以我们可以类型加值来作为key，把上面的改一下

```js
function uniqune(arr) {
    let obj = {}
    return arr.filter((item) =>{
        return obj.hasOwnProperty(typeof item + item) ? false : obj[typeof item + item] = true
    })

```

这样就没有问题了。这时有同学就会想到我们可不可以用map来直接实现。我的答案是可以的，直接上代码

```js
function uniqune(arr) {
    let map = new Map()
    return arr.filter((item) =>{
        return map.has(item) ? false : map.set(item,true)
    })
}
```

### Set

这个是我们最常用的方法，也是比较简单的

```js
function uniqune(arr) {
    let map = new Set(arr)
    return [...map]
}
```

### 写在最后

indexOf 底层还是使用 === 进行判断，因为 NaN ==== NaN的结果为 false，所以使用 indexOf 查找不到 NaN 元素

Set 认为尽管 NaN === NaN 为 false，但是这两个元素是重复的
